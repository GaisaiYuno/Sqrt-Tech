https://c-t.work/s/fb2e6fdf230547

- 分块？

常数小，能够**在线**，思维难度小。

根据zkw巨佬说的，分块内存连续，然后可能跑得比log还快。

- 分块的本质？

一棵深度只有$3$，每个节点有$\sqrt n$个孩子的树。

分块保证区间修改只用动用$\sqrt n$级别的节点，单点修改只用动用$2$个节点（视情况而变）

对比线段树：区间修改$\log n$级别的节点，单点修改$\log n$级别的节点。

![img](https://s2.ax1x.com/2019/05/02/ENpT4x.png)

经常的做法：维护区间之内信息，维护连续区间之间信息，维护区间前缀，后缀信息，每个块打上区间标记之类。

# 序列分块

## 例题1

[P3203 [HNOI2010]弹飞绵羊](http://119.29.55.79/problem/2051)

容易发现是一棵树/森林，因为一个点只能往后面连边，并且只连一条边。

题目变成改变一条边的终点，维护一个点的深度。

如果你这样想就是LCT的裸题了。

但是为了维护尊严，我们不写LCT。

考虑分块，假设我们现在有一个点$x$，预处理跳几步能够跳出这个点所在的块，步数记为$dep[x]$，跳到的那个点记为$to[x]$（$n$及以后的点编号为$0$，看作一个不同的块）

注意到我们更新一个点要更新这个点所在的块中，编号在这个点前面的所有点，因为前面的点也可能跳到这个点，导致$dep,to$变化。

当然你也可以更新整个块，只是常数大了一点。

不开O2会被卡一个点，但是开了O2跑得极快。

$O(m\sqrt{n})$，然而$n\le200000,m\le100000$，约为$5 \times 10^7$，说明常数还是挺小的。

```cpp
#include <bits/stdc++.h>
#define MAXN 200005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int dep[MAXN],to[MAXN];//预处理一个点跳多少步能跳出这个块，跳到哪里
int n,Size,a[MAXN],pos[MAXN];
void Rebuild(int p,int id){
	int l=(id-1)*Size,r=min(p,id*Size-1);
	for (int i=r;i>=l;--i){//倒着搞
		if (pos[a[i]]!=pos[i]) dep[i]=1,to[i]=a[i];
		else dep[i]=dep[a[i]]+1,to[i]=to[a[i]];
	}
}
int Query(int x){
	int ans=0;
	while (true){
		ans+=dep[x],x=to[x];
		if (pos[x]==0) return ans;
	}
	return -1;
}
int main(){
	n=read();
	for (int i=0;i<n;++i) a[i]=i+read();//弹到哪个位置
	Size=sqrt(n);
	for (int i=0;i<n;++i) pos[i]=i/Size+1;
	for (int i=1;i<=pos[n-1];++i) Rebuild(0x7fffffff,i);
	int m=read();
	while (m--){
		int opr=read(),i=read();
		if (opr==1){
			printf("%d\n",Query(i));
		}
		else {
			a[i]=i+read();
			Rebuild(i,pos[i]);
		}
	}
}
```

## 例题2

[#2001. Karen loves Sqrt Tech 1「CodeChef」](http://119.29.55.79/problem/2001)

原题：[CODECHEF Nov. Challenge 2014 Chef & Churu](https://s3.amazonaws.com/codechef_shared/download/translated/NOV14/mandarin/FNCS.pdf)

### 对于没有$3$操作的情况：

首先想到改变一个元素，会影响哪些函数值。

容易发现，当$L_i \le x \le R_i$时，改变一个元素会对这个函数造成$\Delta$的贡献。

考虑分块，对于连续$\sqrt{n}$个的函数分成一块，维护块内函数值之和，并且维护$cnt[x]=\sum [L_i \le x \le R_i]$。

修改要修改每一个块，时间复杂度$O(\sqrt n)$。

对于查询，中间$\sqrt n$个块可以$O(1)$得出答案，但是对于剩下两边$\sqrt n$个多出来的函数，我们需要快速得出和。

当然树状数组是可以做的，但是**太屑了**，只能做到$O(n \sqrt n \log n)$，然后被我卡掉了。

注意到修改只用修改一个数，所以只要保证修改时间复杂度小于$\sqrt n$即可。

然而我们要尽量减少查询的时间复杂度，因为查询查询了$\sqrt n$级别的数。

于是可以想到继续对$a$数组分块，一开始是这么想的：

warning：注意区分块前缀和和块内前缀和

维护块内前缀和，后缀和，维护所有块前缀和。

每次修改只用更改块内前缀和，后缀和，然后这个块之后块前缀和都要加上那个数。

每次查询只需要查询前面的块内后缀和，后面的块内前缀和，然后中间的块前缀和一减就知道了，如果在同一个块里面，只需要块内前缀和相减即可。

显然这是一种比较繁琐的做法，但是当然可行。

注意到我们可以维护$a$的前缀和数组$sum$，然后就可以发现对于更新，只要打一个标记即可。

这就告诉我们差分可以大大减少码量。

优美的代码实现：

```cpp
ull sum[MAXN],tag[MAXM];
void Update(int i,int delta){//会对i及以后的造成delta的变化
	int id=pos[i],rb=min(id*Size,n);
	for (int j=i;j<=rb;++j) sum[j]+=delta;
	for (int j=id+1;j<=pos[n];++j) tag[j]+=delta;
}
ull GetVal(int i){
	return sum[i]+tag[pos[i]];
}
ull Sum(int l,int r){
	return GetVal(r)-GetVal(l-1);
}
```

std（50pts）:

```cpp
#include <bits/stdc++.h>
#define MAXN 100005
#define MAXM 405
#define ull unsigned long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int a[MAXN],Size,pos[MAXN],n;
namespace alb{
	ull sum[MAXN],tag[MAXM];//delta只是int级别的
	void Update(int i,int delta){//会对i及以后的造成delta的变化
		int id=pos[i],rb=min(id*Size,n);
		for (int j=i;j<=rb;++j) sum[j]+=delta;
		for (int j=id+1;j<=pos[n];++j) tag[j]+=delta;
	}
	ull GetVal(int i){
		return sum[i]+tag[pos[i]];
	}
	ull Sum(int l,int r){
		return GetVal(r)-GetVal(l-1);
	}
}
using namespace alb;
int cnt[MAXM][MAXN];
ull val[MAXM];
int L[MAXN],R[MAXN];
void Init(){
	for (int i=1;i<=pos[n];++i){
		int lb=(i-1)*Size+1,rb=min(i*Size,n);
		for (int j=lb;j<=rb;++j) cnt[i][L[j]]++,cnt[i][R[j]+1]--;
		for (int j=1;j<=n;++j) cnt[i][j]+=cnt[i][j-1];
	}
}
void Rebuild(int index,int delta){
	for (int i=1;i<=pos[n];++i) val[i]+=1ull*delta*cnt[i][index];
	Update(index,delta);
}
ull BF(int l,int r){
	ull ans=0;
	for (int i=l;i<=r;++i) ans+=Sum(L[i],R[i]);
	return ans;
}
ull Query(int l,int r){
	if (pos[l]==pos[r]) return BF(l,r);
	int lid=pos[l],rid=pos[r];
	int rb=min(lid*Size,n),lb=(rid-1)*Size+1;
	ull ans=BF(l,rb)+BF(lb,r);
	for (int i=lid+1;i<=rid-1;++i) ans+=val[i];
	return ans;
}
int main(){
	n=read();
	for (int i=1;i<=n;++i) a[i]=read();
	for (int i=1;i<=n;++i){L[i]=read();R[i]=read();}
	Size=sqrt(n);
	for (int i=1;i<=n;++i) pos[i]=(i-1)/Size+1;
	Init();
	for (int i=1;i<=n;++i) Rebuild(i,a[i]);
	int q=read();
	while (q--){
		int opr=read();
		if (opr==1){
			int x=read(),y=read();
			Rebuild(x,y-a[x]);
			a[x]=y;
		}
		else {
			int l=read(),r=read();
			printf("%llu\n",Query(l,r));
		}
	}
}
```

### 对于有$3$操作的情况：

发现我们需要动态维护$cnt$数组。

注意到我们可以再开一个分块，维护每一块里面的$cnt$。

然后维护$val$也没什么大不了的，就直接减去之间的贡献，加上现在的贡献即可。

时间复杂度$O(n \sqrt n)$

std（100pts）:

```cpp
#include <bits/stdc++.h>
#define MAXN 200005
#define MAXM 505
#define ull long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int a[MAXN],Size,pos[MAXN],n;
struct FK1{
	ull sum[MAXN],tag[MAXM];
	void Update(int i,int v){
		int id=pos[i],rb=min(id*Size,n);
		for (int j=i;j<=rb;++j) sum[j]+=v;
		for (int j=id+1;j<=pos[n];++j) tag[j]+=v;
	}
	ull GetVal(int i){
		return sum[i]+tag[pos[i]];
	}
	ull Sum(int l,int r){
		return GetVal(r)-GetVal(l-1);
	}
}Kaffu;
struct FK2{
	int sum[MAXN],tag[MAXM];
	void BF(int l,int r,int v){
		for (int j=l;j<=r;++j) sum[j]+=v;
	}
	void Update(int l,int r,int v){
		int lid=pos[l],rid=pos[r];
		if (lid==rid) return BF(l,r,v),void();
		int rb=min(lid*Size,n),lb=(rid-1)*Size+1;
		BF(l,rb,v),BF(lb,r,v);
		for (int i=lid+1;i<=rid-1;++i) tag[i]+=v;
	}
	int GetVal(int i){
		return sum[i]+tag[pos[i]];
	}
}Chino[MAXM];
int cnt[MAXM][MAXN];
ull val[MAXM];
int L[MAXN],R[MAXN];
void Init(){
	for (int i=1;i<=pos[n];++i){
		int lb=(i-1)*Size+1,rb=min(i*Size,n);
		for (int j=lb;j<=rb;++j) Chino[i].Update(L[j],R[j],1);
	}
}
void Rebuild(int index,int v){
	for (int i=1;i<=pos[n];++i) val[i]+=1ull*v*Chino[i].GetVal(index);
	Kaffu.Update(index,v);
}
void UpdateInterval(int index,int l,int r){
	int id=pos[index];
	val[id]-=Kaffu.Sum(L[index],R[index]);
	val[id]+=Kaffu.Sum(l,r);
	Chino[id].Update(L[index],R[index],-1);
	Chino[id].Update(l,r,1);
	L[index]=l,R[index]=r;
}
ull BF(int l,int r){
	ull ans=0;
	for (int i=l;i<=r;++i) ans+=Kaffu.Sum(L[i],R[i]);
	return ans;
}
ull Query(int l,int r){
	int lid=pos[l],rid=pos[r];
	if (lid==rid){
		return BF(l,r);
	}
	int rb=min(lid*Size,n),lb=(rid-1)*Size+1;
	ull ans=BF(l,rb)+BF(lb,r);
	for (int i=lid+1;i<=rid-1;++i) ans+=val[i];
	return ans;
}
int main(){
	n=read();
	for (int i=1;i<=n;++i) a[i]=read();
	for (int i=1;i<=n;++i){L[i]=read();R[i]=read();}
	Size=sqrt(n);
	for (int i=1;i<=n;++i) pos[i]=(i-1)/Size+1;
	Init();
	for (int i=1;i<=n;++i) Rebuild(i,a[i]);
	int q=read();
	while (q--){
		int opr=read();
		if (opr==1){
			int p=read(),x=read();
			Rebuild(p,x-a[p]);
			a[p]=x;
		}
		else if (opr==2){
			int l=read(),r=read();
			printf("%lld\n",Query(l,r));
		}
		else {
			int p=read(),l=read(),r=read();
			UpdateInterval(p,l,r);
		}
	}
}
```

## 例题3

这题做法很多。

### Sol1 莫队+分块

这个其实是最智障的思路了。

对于每个元素，维护一个$deque$，存的是这个元素出现的下标，每次莫队操作刚好对应了$\rm pushfront,pushback,popfront,popback$四种操作。

也要维护$Max[i]$，代表元素$i$的队头和队尾差。

于是发现我们需要维护$Max[i]$的最大值，且支持单点修改。

这个可以用线段树$\log n$实现，但是肯定不是最优。

考虑**值域分块**，维护$cnt$，代表每个元素的出现次数，每个块开一个$sum$，表示块内$cnt$值之和。

要求最大值，就从后面扫过来，如果这个块有值，再遍历整个块即可。

分块实现：

```cpp
namespace Kaffu{
	int cnt[MAXN],sum[MAXM];
	void Update(int index,int v){
		cnt[index]+=v;
		sum[pos[index]]+=v;
	}
	int GetMax(){
		for (int i=pos[n];i>=0;--i){
			if (sum[i]){
				int lb=(i-1)*Size+1,rb=min(i*Size,n);
				for (int j=rb;j>=lb;--j){
					if (cnt[j]) return j;
				}
			}
		}
		return 0;
	}
};
```

然后就爆搞即可，需要注意细节。

时间复杂度$O(n \sqrt n)$，空间复杂度$O(n)$。

```cpp
#include <bits/stdc++.h>
#define MAXN 100005
#define MAXM 320
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int pos[MAXN];
struct Query{
	int l,r,id;
}Q[MAXN];
bool operator < (Query a,Query b){
    return pos[a.l]<pos[b.l]||(pos[a.l]==pos[b.l]&&((pos[a.l]&1)?a.r<b.r:a.r>b.r));
}
static deque<int>Chino[MAXN];
int a[MAXN],n,m,q,Size;
namespace Kaffu{
	int cnt[MAXN],sum[MAXM];
	void Update(int index,int v){
		cnt[index]+=v;
		sum[pos[index]]+=v;
	}
	int GetMax(){
		for (int i=pos[n];i>=0;--i){
			if (sum[i]){
				int lb=(i-1)*Size+1,rb=min(i*Size,n);
				for (int j=rb;j>=lb;--j){
					if (cnt[j]) return j;
				}
			}
		}
		return 0;
	}
};
using namespace Kaffu;
int Calc(int x){
	if (Chino[x].size()<1) return -1;
	return Chino[x].back()-Chino[x].front();
}
void PushBack(int index,int x){
	int pre=Calc(x);
	Chino[x].push_back(index);
	int aft=Calc(x);
	if (pre==-1) Update(aft,1);
	else Update(pre,-1),Update(aft,1);
}
void PopBack(int x){
	int pre=Calc(x);
	Chino[x].pop_back();
	int aft=Calc(x);
	if (aft==-1) Update(pre,-1);
	else Update(pre,-1),Update(aft,1);
}
void PushFront(int index,int x){
	int pre=Calc(x);
	Chino[x].push_front(index);
	int aft=Calc(x);
	if (pre==-1) Update(aft,1);
	else Update(pre,-1),Update(aft,1);
}
void PopFront(int x){
	int pre=Calc(x);
	Chino[x].pop_front();
	int aft=Calc(x);
	if (aft==-1) Update(pre,-1);
	else Update(pre,-1),Update(aft,1);
}
int Ans[MAXN];
int main(){
	n=read(),m=read(),q=read();
	int Max=max(m,n);
	Size=sqrt(Max)+600;
	for (int i=1;i<=Max;++i) pos[i]=(i-1)/Size+1;
	for (int i=1;i<=n;++i) a[i]=read();
	for (int i=1;i<=q;++i){
		int l=read(),r=read();
		Q[i]=Query{l,r,i};
	}
	sort(Q+1,Q+1+q);
	int l=1,r=0;
	for (int i=1;i<=q;++i){
		while (l>Q[i].l) --l,PushFront(l,a[l]);
		while (r<Q[i].r) ++r,PushBack(r,a[r]);
		while (l<Q[i].l) PopFront(a[l]),++l;
		while (r>Q[i].r) PopBack(a[r]),--r;
		Ans[Q[i].id]=GetMax();
	}
	for (int i=1;i<=q;++i) printf("%d\n",Ans[i]);
}
```

### Sol2 回滚莫队

可以想到回滚莫队。

我们称回滚莫队中左边大小小于$\sqrt n$的那个块为左块，右边的那个块为右块。

对于每个块，维护每个元素最早出现的位置，最晚出现的位置，记为$L_{min},L_{max},R_{min},R_{max}$

发现答案可能来自三个地方，全部属于左块；全部属于右块；$i$属于左块，$j$属于右块。

对应的就是$L_{max}-L_{min},R_{max}-R_{min},R_{max}-L_{min}$

在三个里面求最大值即可。

我太懒了，没写。

### Sol3 分块

这个分块还是比较不好想的。

维护$lst[id][i],fst[id][i]$。

其中$fst[id][i]$表示，从第$id$块的左端点开始向后，最左边的$i$；$lst[id][i]$表示，从第$id$块的右端点开始向前，最右边的$i$。

然后这个初始化就考虑一个数能对那些做贡献：

```cpp
memset(fst,0x3f,sizeof(fst));
memset(lst,~0x3f,sizeof(lst));
for (int i=1;i<=n;++i){
	int id=pos[i];
	for (int j=1;j<=id;++j){//只能对前面的做贡献
		fst[j][a[i]]=min(fst[j][a[i]],i);
	}
	for (int j=id;j<=pos[n];++j){//只能对后面的做贡献
		lst[j][a[i]]=max(lst[j][a[i]],i);
	}
}
```

然后再考虑查询，显然我们需要再预处理出$f[l][r]$，代表编号从$l$到$r$的块中的最大值。

如何预处理，想到区间dp，首先$f[i][j]=\max(f[i][j-1],f[i+1][j])$，然后考虑$i$块到$j$块的贡献，代码大概长这样：

```cpp
for (int k=lb;k<=rb;++k){
	f[i][j]=max(f[i][j],lst[j][a[k]]-k);
}
```

因为两边是对称的，所以可以只计算一边到另一边的。

总代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 100005
#define MAXM 320
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int n,m,q;
int a[MAXN],Size;
int fst[MAXM][MAXN],lst[MAXM][MAXN];
int pos[MAXN];
//fst[id][i]表示，从第id块的左端点开始，最左边的i
//lst[id][i]表示，从第id块的右端点开始，最右边的i
int f[MAXM][MAXM];//从第i块到第j块
void Init(){
	memset(fst,0x3f,sizeof(fst));
	memset(lst,~0x3f,sizeof(lst));
	for (int i=1;i<=n;++i){
		int id=pos[i];
		for (int j=1;j<=id;++j){
			fst[j][a[i]]=min(fst[j][a[i]],i);
		}
		for (int j=id;j<=pos[n];++j){
			lst[j][a[i]]=max(lst[j][a[i]],i);
		}
	}
	for (int i=pos[n];i>=1;--i){
		for (int j=1;j<=pos[n];++j){
			f[i][j]=max(f[i][j-1],f[i+1][j]);
             int lb=(i-1)*Size+1,rb=min(i*Size,n);
			for (int k=lb;k<=rb;++k){
				f[i][j]=max(f[i][j],lst[j][a[k]]-k);
			}
		}
	}
}
int pre[MAXN];
int Query(int l,int r){
	if (pos[l]==pos[r]){
		int ans=0;
		for (int i=l;i<=r;++i){
			if (!pre[a[i]]) pre[a[i]]=i;
			else ans=max(ans,i-pre[a[i]]);
		}
		for (int i=l;i<=r;++i) pre[a[i]]=0;
		return ans;
	}
	int lid=pos[l],rid=pos[r];
	int rb=min(lid*Size,n),lb=(rid-1)*Size+1;
	int ans=f[lid+1][rid-1];
	for (int i=l;i<=rb;++i){
		if (!pre[a[i]]) pre[a[i]]=i;
		else ans=max(ans,i-pre[a[i]]);
		ans=max(ans,lst[rid-1][a[i]]-i);
	}
	for (int i=lb;i<=r;++i){
		if (!pre[a[i]]) pre[a[i]]=i;
		else ans=max(ans,i-pre[a[i]]);
		ans=max(ans,i-fst[lid+1][a[i]]);
	}
	for (int i=l;i<=rb;++i) pre[a[i]]=0;
	for (int i=lb;i<=r;++i) pre[a[i]]=0;
	return ans;
}
int main(){
	n=read(),m=read(),q=read();
	Size=sqrt(n);
	for (int i=1;i<=n;++i){
		pos[i]=(i-1)/Size+1;
	}
	for (int i=1;i<=n;++i){
		a[i]=read();
	}
	Init();
	while (q--){
		int l=read(),r=read();
		printf("%d\n",Query(l,r));
	}
}
```

## 例题4

[#2059. Regions「IOI2009」](http://119.29.55.79/problem/2059)

我们可以想到一个naive的暴力，对于一个节点$x$，颜色为$r_2$，我们发现只有他到根节点路径上面颜色为$r_1$的节点才会对询问$(r_1,r_2)$做出贡献，那么我们可以写出如下代码：

```cpp
void dfs1(int u,int father){
	buc[r[u]]++;
	for (int i=0;i<Q1[r[u]].size();++i){
		ans[Q1[r[u]][i].id]+=buc[Q1[r[u]][i].c];
	}
	for (int i=0;i<G[u].size();++i){
		int v=G[u][i];
		if (v!=father) dfs1(v,u);
	}
	buc[r[u]]--;
}
```

令询问里面$r_2=x$的次数为$cnt(x)$，这样我们发现时间复杂度是$O(\sum cnt(r[u]))$，我们发现