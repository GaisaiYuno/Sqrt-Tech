# 分块

分块？

常数小，能够**在线**，思维难度小。

分块的本质？

一棵深度只有$3$，每个节点有$\sqrt n$个孩子的树。

分块保证区间修改只用动用$\sqrt n$级别的节点，单点修改只用动用$2$个节点（视情况而变）

对比线段树：区间修改$\log n$级别的节点，单点修改$\log n$级别的节点。

![img](https://s2.ax1x.com/2019/05/02/ENpT4x.png)

经常的做法：维护区间之内信息，维护连续区间之间信息，维护区间前缀，后缀信息，每个块打上区间标记之类。

## 例题1

[P3203 [HNOI2010]弹飞绵羊](https://www.luogu.org/problem/P3203)

容易发现是一棵树/森林，因为一个点只能往后面连边，并且只连一条边。

题目变成改变一条边的终点，维护一个点的深度。

如果你这样想就是LCT的裸题了。

但是为了维护尊严，我们不写LCT。

考虑分块，假设我们现在有一个点$x$，预处理跳几步能够跳出这个点所在的块，步数记为$dep[x]$，跳到的那个点记为$to[x]$（$n$及以后的点编号为$0$，看作一个不同的块）

注意到我们更新一个点要更新这个点所在的块中，编号在这个点前面的所有点，因为前面的点也可能跳到这个点，导致$dep,to$变化。

当然你也可以更新整个块，只是常数大了一点。

不开O2会被卡一个点，但是开了O2跑得极快。

$O(m\sqrt{n})$，然而$n\le200000,m\le100000$，约为$5 \times 10^7$，说明常数还是挺小的。

```cpp
#include <bits/stdc++.h>
#define MAXN 200005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int dep[MAXN],to[MAXN];//预处理一个点跳多少步能跳出这个块，跳到哪里
int n,Size,a[MAXN],pos[MAXN];
void Rebuild(int p,int id){
	int l=(id-1)*Size,r=min(p,id*Size-1);
	for (int i=r;i>=l;--i){//倒着搞
		if (pos[a[i]]!=pos[i]) dep[i]=1,to[i]=a[i];
		else dep[i]=dep[a[i]]+1,to[i]=to[a[i]];
	}
}
int Query(int x){
	int ans=0;
	while (true){
		ans+=dep[x],x=to[x];
		if (pos[x]==0) return ans;
	}
	return -1;
}
int main(){
	n=read();
	for (int i=0;i<n;++i) a[i]=i+read();//弹到哪个位置
	Size=sqrt(n);
	for (int i=0;i<n;++i) pos[i]=i/Size+1;
	for (int i=1;i<=pos[n-1];++i) Rebuild(0x7fffffff,i);
	int m=read();
	while (m--){
		int opr=read(),i=read();
		if (opr==1){
			printf("%d\n",Query(i));
		}
		else {
			a[i]=i+read();
			Rebuild(i,pos[i]);
		}
	}
}
```

## 例题2

[CODECHEF Nov. Challenge 2014 Chef & Churu](https://s3.amazonaws.com/codechef_shared/download/translated/NOV14/mandarin/FNCS.pdf)

首先想到改变一个元素，会影响哪些函数值。

容易发现，当$L_i \le x \le R_i$时，改变一个元素会对这个函数造成$\Delta$的贡献。

考虑分块，对于连续$\sqrt{n}$个的函数分成一块，维护块内函数值之和，并且维护$cnt[x]=\sum [L_i \le x \le R_i]$。

修改要修改每一个块，时间复杂度$O(\sqrt n)$。

对于查询，中间$\sqrt n$个块可以$O(1)$得出答案，但是对于剩下两边$\sqrt n$个多出来的函数，我们需要快速得出和。

当然树状数组是可以做的，但是**太屑了**，只能做到$O(n \sqrt n \log n)$，虽然能过。

注意到修改只用修改一个数，所以只要保证修改时间复杂度小于$\sqrt n$即可。

然而我们要尽量减少查询的时间复杂度，因为查询查询了$\sqrt n$级别的数。

于是可以想到继续对$a$数组分块，一开始是这么想的：

维护块内前缀和，后缀和，维护所有块的前缀和。

每次修改只用更改块内前缀和，后缀和，然后这个块之后块间前缀和都要加上那个数。

每次查询只需要查询块前前缀和，块后前缀和，然后中间的块前缀和一减就知道了，如果在同一个块里面，只需要块内前缀和相减即可。

显然这是一种比较繁琐的做法，但是当然可行。

注意到我们可以维护$a$的前缀和数组$sum$，然后就可以发现只要打一个标记即可（这里实际上是访问了叶节点和根节点的子节点）

优美的代码实现：

```cpp
ull sum[MAXN],tag[MAXM];
void Update(int i,int delta){//会对i及以后的造成delta的变化
	int id=pos[i],rb=min(id*Size,n);
	for (int j=i;j<=rb;++j) sum[j]+=delta;
	for (int j=id+1;j<=pos[n];++j) tag[j]+=delta;
}
ull GetVal(int i){
	return sum[i]+tag[pos[i]];
}
ull Sum(int l,int r){
	return GetVal(r)-GetVal(l-1);
}
```

std:

```cpp
#include <bits/stdc++.h>
#define MAXN 100005
#define MAXM 405
#define ull unsigned long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int a[MAXN],Size,pos[MAXN],n;
namespace alb{
	ull sum[MAXN],tag[MAXM];//delta只是int级别的
	void Update(int i,int delta){//会对i及以后的造成delta的变化
		int id=pos[i],rb=min(id*Size,n);
		for (int j=i;j<=rb;++j) sum[j]+=delta;
		for (int j=id+1;j<=pos[n];++j) tag[j]+=delta;
	}
	ull GetVal(int i){
		return sum[i]+tag[pos[i]];
	}
	ull Sum(int l,int r){
		return GetVal(r)-GetVal(l-1);
	}
}
using namespace alb;
int cnt[MAXM][MAXN];
ull val[MAXM];
int L[MAXN],R[MAXN];
void Init(){
	for (int i=1;i<=pos[n];++i){
		int lb=(i-1)*Size+1,rb=min(i*Size,n);
		for (int j=lb;j<=rb;++j) cnt[i][L[j]]++,cnt[i][R[j]+1]--;
		for (int j=1;j<=n;++j) cnt[i][j]+=cnt[i][j-1];
	}
}
void Rebuild(int index,int delta){
	for (int i=1;i<=pos[n];++i) val[i]+=1ull*delta*cnt[i][index];
	Update(index,delta);
}
ull BF(int l,int r){
	ull ans=0;
	for (int i=l;i<=r;++i) ans+=Sum(L[i],R[i]);
	return ans;
}
ull Query(int l,int r){
	if (pos[l]==pos[r]) return BF(l,r);
	int lid=pos[l],rid=pos[r];
	int rb=min(lid*Size,n),lb=(rid-1)*Size+1;
	ull ans=BF(l,rb)+BF(lb,r);
	for (int i=lid+1;i<=rid-1;++i) ans+=val[i];
	return ans;
}
int main(){
	n=read();
	for (int i=1;i<=n;++i) a[i]=read();
	for (int i=1;i<=n;++i){L[i]=read();R[i]=read();}
	Size=sqrt(n);
	for (int i=1;i<=n;++i) pos[i]=(i-1)/Size+1;
	Init();
	for (int i=1;i<=n;++i) Rebuild(i,a[i]);
	int q=read();
	while (q--){
		int opr=read();
		if (opr==1){
			int x=read(),y=read();
			Rebuild(x,y-a[x]);
			a[x]=y;
		}
		else {
			int l=read(),r=read();
			printf("%llu\n",Query(l,r));
		}
	}
}
```

### 补充

考虑加上第三个操作$\text{3 id l r}$表示把$L[id]$改成$l$，$R[id]$改成$r$。

然后发现我们需要动态维护$cnt$数组。

注意到我们可以再开一个分块，维护每一块里面的$cnt$，然后加入一个区间可以后缀和搞一下，适配刚才我们写好的维护$a$的分块。

然后维护$val$也没什么大不了的，就直接减去之间的贡献，加上现在的贡献即可。

时间复杂度$O(n \sqrt n)$

## 例题3

